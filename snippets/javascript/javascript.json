{
  "JSON.stringify()": {
    "prefix": ";js",
    "body": "JSON.stringify($0)"
  },
  "JSON.stringify() pretty": {
    "prefix": ";jsp",
    "body": "JSON.stringify($0, null, 2)"
  },
  "JSON.parse()": {
    "prefix": ";jp",
    "body": "JSON.parse($0)"
  },
  "console.log": {
    "prefix": ";ll",
    "body": "console.log(${0});"
  },
  "console.info": {
    "prefix": ";li",
    "body": "console.info(${0});"
  },
  "console.error": {
    "prefix": ";le",
    "body": "console.error(${0});"
  },
  "console.warn": {
    "prefix": ";lw",
    "body": "console.warn(${0});"
  },
  "let statement": {
    "prefix": ";l",
    "body": "let ${2:name} = ${1:value};"
  },
  "const statement": {
    "prefix": ";c",
    "body": "const ${2:name} = ${1:value};"
  },
  "const assignment awaited": {
    "prefix": ";ca",
    "body": "const ${2:name} = await ${1:value};"
  },
  "const arrow function assignment": {
    "prefix": ";cf",
    "body": "const ${1:name} = (${2:arguments}) => {\n\t${0}\n};"
  },
  "process.env": {
    "prefix": ";pe",
    "body": "const { $0 } = process.env;"
  },
  "module default": {
    "prefix": ";e",
    "body": "export { ${1:member} };"
  },
  "module default export": {
    "prefix": ";ed",
    "body": "export default ${1:member};"
  },
  "import module": {
    "prefix": ";imp",
    "body": "import ${2:*} from '${1:module}';"
  },
  "import module as": {
    "prefix": ";impa",
    "body": "import ${2:*} as ${3:name} from '${1:module}';"
  },
  "require": {
    "prefix": ";req",
    "body": "const { ${2} } = require('${1:module}');"
  },
  "module.exports": {
    "prefix": ";me",
    "body": "module.exports = { ${1:name} };"
  },
  "If Statement": {
    "prefix": ";if",
    "body": ["if (${1:condition}) {", "\t$2", "}"]
  },
  "If-Else Statement": {
    "prefix": ";ife",
    "body": ["if (${1:condition}) {", "\t$2", "} else {", "\t$3", "}"]
  },
  "else statement": {
    "prefix": ";el",
    "body": "else {\n\t${0}\n}"
  },
  "else if statement": {
    "prefix": ";eli",
    "body": "else if (${1:condition}) {\n\t${0}\n}"
  },
  "Switch Statement": {
    "prefix": ";switch",
    "body": [
      "switch (${1:key}) {",
      "\tcase ${2:value}:",
      "\t\t$3",
      "\t\tbreak;$4",
      "\tdefault:",
      "\t\t$5",
      "\t\tbreak;",
      "}"
    ]
  },
  "ternary": {
    "prefix": ";te",
    "body": "${1:cond} ? ${2:true} : ${3:false}"
  },
  "find": {
    "prefix": ";find",
    "body": "${1:iterable}.find((${2:item}) => {\n\t${0}\n})"
  },
  "every": {
    "prefix": ";every",
    "body": "${1:iterable}.every((${2:item}) => {\n\t${0}\n})"
  },
  "some": {
    "prefix": ";some",
    "body": "${1:iterable}.some((${2:item}) => {\n\t${0}\n})"
  },
  "forEach loop": {
    "prefix": ";foreach",
    "body": "${1:iterable}.forEach((${2:item}) => {\n\t${0}\n});"
  },
  "map": {
    "prefix": ";map",
    "body": "${1:iterable}.map((${2:item}) => {\n\t${0}\n})"
  },
  "reduce": {
    "prefix": ";reduce",
    "body": "${1:iterable}.reduce((${2:accum}, ${3:item}) => {\n\t${0}\n}${4:, initial})"
  },
  "filter": {
    "prefix": ";filter",
    "body": "${1:iterable}.filter((${2:item}) => {\n\t${0}\n})"
  },
  "Object.keys": {
    "prefix": ";objk",
    "body": "Object.keys(${1:obj})"
  },
  "Object.values": {
    "prefix": ";objv",
    "body": "Object.values(${1:obj})"
  },
  "Object.entries": {
    "prefix": ";obje",
    "body": "Object.entries(${1:obj})"
  },
  "Object.freeze": {
    "prefix": ";objf",
    "body": "Object.freeze(${1:obj})"
  },
  "named function": {
    "prefix": ";f",
    "body": "${1:async} function ${2:name}(${3:arguments}) {\n\t${0}\n}"
  },
  "arrow function": {
    "prefix": ";fn",
    "body": "${1:async} (${2:arguments}) => {\n\t${0}\n}"
  },
  "immediately-invoked function expression": {
    "prefix": ";iife",
    "body": "(${1:async} function (${2:arguments}) {\n\t${0}\n})(${3});"
  },
  "named generator": {
    "prefix": ";fg",
    "body": "function* ${1:name}(${2:arguments}) {\n\t${0}\n}"
  },
  "While Statement": {
    "prefix": ";w",
    "body": ["while (${1:condition}) {", "\t$0", "}"]
  },
  "Do-While Statement": {
    "prefix": ";dw",
    "body": ["do {", "\t$0", "} while (${1:condition});"]
  },
  "For-Of Loop": {
    "prefix": ";for",
    "body": ["for $1(const ${3:item} of ${2:object}) {", "\t$0", "}"]
  },
  "For Loop": {
    "prefix": ";fori",
    "body": [
      "for (let ${1:i} = 0; ${1:i} < ${2:count}; ${1:i}++) {",
      "\t$0",
      "}"
    ]
  },
  "try/catch": {
    "prefix": ";tc",
    "body": "try {\n\t$1\n} catch (${2:error}) {\n\t$0\n}"
  },
  "try/finally": {
    "prefix": ";tf",
    "body": "try {\n\t$1\n} finally {\n\t$0\n}"
  },
  "try/catch/finally": {
    "prefix": ";tcf",
    "body": "try {\n\t$1\n} catch (${2:error}) {\n\t$3\n} finally {\n\t$4\n}"
  },
  "throw new Error": {
    "prefix": ";throw",
    "body": "throw new ${0:Error($1)};"
  },
  "debugger statement": {
    "prefix": ";d",
    "body": "debugger;"
  },
  "describe": {
    "prefix": ";td",
    "body": "describe('${1:description}', () => {\n\t${0}\n});"
  },
  "it asynchronous": {
    "prefix": ";tt",
    "body": "it('${1:description}', ${2:async }() => {\n\t${0}\n});"
  },
  "it.todo": {
    "prefix": ";ttodo",
    "body": "it.todo('${1:description}');"
  },
  "beforeAll": {
    "prefix": ";tba",
    "body": "beforeAll(${1:async }() => {\n\t${0}\n});"
  },
  "before": {
    "prefix": ";tbe",
    "body": "beforeEach(${1:async }() => {\n\t${0}\n});"
  },
  "afterAll": {
    "prefix": ";taa",
    "body": "afterAll(${1:async }()=> {\n\t${0}\n});"
  },
  "afterEach": {
    "prefix": ";tae",
    "body": "afterEach(${1:async }()=> {\n\t${0}\n});"
  },
  "Set Timeout Function": {
    "prefix": ";st",
    "body": ["setTimeout(() => {", "\t$0", "}, ${1:timeout});"]
  },
  "Set Interval Function": {
    "prefix": ";si",
    "body": ["setInterval(() => {", "\t$0", "}, ${1:interval});"]
  },
  "await Promise.all": {
    "prefix": ";pa",
    "body": "await Promise.all([\n\t${1:value}\n]);"
  },
  "await Promise.all map": {
    "prefix": ";pam",
    "body": "await Promise.all(${1:array}.map(async (${2:value}) => {\n\t${0}\n}));"
  },
  "await sleep": {
    "prefix": ";ps",
    "body": "await new Promise((r) => setTimeout(r, ${0}));"
  },
  "Promise.resolve": {
    "prefix": ";pr",
    "body": "Promise.resolve(${1:value})"
  },
  "Promise.reject": {
    "prefix": ";pR",
    "body": "Promise.reject(${1:value})"
  },
  "new Promise": {
    "prefix": ";pn",
    "body": "new Promise((resolve, reject) => {\n\t${0}\n})"
  }
}
